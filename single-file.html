<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é­”æ³•æ‰‹åŠ¿ç”»æ¿ | MediaPipe Hands</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        }
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #121212;
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }
        h1 {
            color: #4CAF50;
            margin-bottom: 20px;
        }
        #container {
            position: relative;
            width: 90vw;
            max-width: 1024px;
            height: calc(90vw * 9 / 16);
            max-height: 576px;
            border: 2px solid #444;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }
        #video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* æ°´å¹³é•œåƒï¼Œç¬¦åˆç›´è§‰ */
            filter: brightness(0.7); /* é™ä½èƒŒæ™¯äº®åº¦ï¼Œçªå‡ºç¬”è¿¹ */
        }
        #drawingCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: none;
        }
        #ui-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(30, 30, 30, 0.95);
            border: 1px solid #555;
            border-radius: 15px;
            padding: 20px;
            display: none; /* é»˜è®¤éšè— */
            gap: 20px;
            align-items: center;
            z-index: 10;
            backdrop-filter: blur(10px);
        }
        .tool-group, .color-group, .size-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }
        .tool-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 2px solid transparent;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 24px;
            color: #fff;
            background-color: #333;
        }
        .tool-btn.active {
            border-color: #4CAF50;
            background-color: #444;
            box-shadow: 0 0 15px #4CAF50;
        }
        .color-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 3px solid #555;
            cursor: pointer;
            transition: transform 0.2s ease;
        }
        .color-btn.active {
            transform: scale(1.2);
            box-shadow: 0 0 10px currentColor;
        }
        .size-option {
            width: 50px;
            height: 8px;
            background-color: #666;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .size-option.active {
            background-color: #4CAF50;
            box-shadow: 0 0 10px #4CAF50;
        }
        #size-1 { height: 5px; }
        #size-2 { height: 12px; }
        #size-3 { height: 20px; }
        .instructions {
            margin-top: 20px;
            text-align: center;
            font-size: 14px;
            color: #aaa;
            max-width: 800px;
            line-height: 1.6;
        }
        .instructions strong { color: #4CAF50; }
    </style>
</head>
<body>
    <h1>é­”æ³•æ‰‹åŠ¿ç”»æ¿</h1>
    <div id="container">
        <video id="video" playsinline autoplay muted></video>
        <canvas id="drawingCanvas"></canvas>

        <!-- UI æ§åˆ¶é¢æ¿ -->
        <div id="ui-panel">
            <div class="tool-group">
                <div id="pen-btn" class="tool-btn active" title="ç”»ç¬”">âœï¸</div>
                <div id="eraser-btn" class="tool-btn" title="æ©¡çš®æ“¦">ğŸ§½</div>
            </div>
            <div class="color-group">
                <div class="color-btn active" style="background-color: #FFFFFF;" data-color="#FFFFFF"></div>
                <div class="color-btn" style="background-color: #FF3B30;" data-color="#FF3B30"></div>
                <div class="color-btn" style="background-color: #FF9500;" data-color="#FF9500"></div>
                <div class="color-btn" style="background-color: #FFCC00;" data-color="#FFCC00"></div>
                <div class="color-btn" style="background-color: #4CD964;" data-color="#4CD964"></div>
                <div class="color-btn" style="background-color: #5AC8FA;" data-color="#5AC8FA"></div>
                <div class="color-btn" style="background-color: #007AFF;" data-color="#007AFF"></div>
                <div class="color-btn" style="background-color: #5856D6;" data-color="#5856D6"></div>
                <div class="color-btn" style="background-color: #FF2D55;" data-color="#FF2D55"></div>
            </div>
            <div class="size-group">
                <div id="size-1" class="size-option active" data-size="5"></div>
                <div id="size-2" class="size-option" data-size="15"></div>
                <div id="size-3" class="size-option" data-size="30"></div>
            </div>
        </div>
    </div>

    <div class="instructions">
        <p><strong>æ‰‹åŠ¿æŒ‡ä»¤:</strong></p>
        <p>å¼ å¼€æ‰‹æŒ â†’ æ˜¾ç¤º/éšè—æ§åˆ¶é¢æ¿ | é£ŸæŒ‡æ‚¬åœç‚¹å‡» â†’ é€‰æ‹©åŠŸèƒ½ | é£ŸæŒ‡æ‹‡æŒ‡ç›¸è§¦ â†’ å¼€å§‹ä¹¦å†™/æ“¦é™¤</p>
        <p>å•æ‰‹é£ŸæŒ‡ä¸­æŒ‡å¼ å¼€ â†’ æ¸…é™¤ç”»å¸ƒ (é›ªèŠ±æ¶ˆæ•£) | åŒæ‰‹é£ŸæŒ‡å¼ å¼€ â†’ æ”¾å¤§/ç¼©å°ç”»å¸ƒ</p>
    </div>

    <script>
        const videoElement = document.getElementById('video');
        const canvasElement = document.getElementById('drawingCanvas');
        const canvasCtx = canvasElement.getContext('2d');
        const uiPanel = document.getElementById('ui-panel');

        // --- åº”ç”¨çŠ¶æ€ ---
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let currentTool = 'pen';
        let currentColor = '#FFFFFF';
        let currentSize = 5;
        let showUI = false;
        let uiToggleTimeout = null; // UIé˜²æŠ–
        let isScaling = false;
        let initialScaleDistance = 0;
        let currentScale = 1;

        // --- é›ªèŠ±ç²’å­ç³»ç»Ÿ ---
        let flakes = [];
        const GRAVITY = 0.05;
        const WIND_SPEED = 0.2;

        class Flake {
            constructor(x, y, color, size) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.color = color;
                this.velocityY = Math.random() * 1.5 + 0.5;
                this.velocityX = (Math.random() - 0.5) * WIND_SPEED * 2;
                this.opacity = 1;
                this.rotation = Math.random() * 360;
                this.rotationSpeed = (Math.random() - 0.5) * 1;
            }
            update() {
                this.y += this.velocityY;
                this.x += this.velocityX;
                this.velocityY += GRAVITY;
                this.opacity -= 0.005;
                this.rotation += this.rotationSpeed;
            }
            draw() {
                canvasCtx.save();
                canvasCtx.globalAlpha = this.opacity;
                canvasCtx.translate(this.x, this.y);
                canvasCtx.rotate(this.rotation * Math.PI / 180);
                canvasCtx.fillStyle = this.color;
                canvasCtx.beginPath();
                canvasCtx.moveTo(0, -this.size);
                for (let i = 0; i < 5; i++) {
                    canvasCtx.rotate(Math.PI / 5);
                    canvasCtx.lineTo(0, -this.size * 0.5);
                    canvasCtx.rotate(Math.PI / 5);
                    canvasCtx.lineTo(0, -this.size);
                }
                canvasCtx.fill();
                canvasCtx.restore();
            }
        }

        // --- å·¥å…·é€‰æ‹©é€»è¾‘ ---
        document.querySelectorAll('.tool-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                currentTool = e.target.id === 'pen-btn' ? 'pen' : 'eraser';
            });
        });

        document.querySelectorAll('.color-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                currentColor = e.target.dataset.color;
            });
        });

        document.querySelectorAll('.size-option').forEach(option => {
            option.addEventListener('click', (e) => {
                document.querySelectorAll('.size-option').forEach(o => o.classList.remove('active'));
                e.target.classList.add('active');
                currentSize = parseInt(e.target.dataset.size);
            });
        });

        // --- æ‰‹åŠ¿æ£€æµ‹ä¸äº¤äº’é€»è¾‘ ---
        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 0, // ä½¿ç”¨è½»é‡æ¨¡å‹ï¼Œæå‡æ€§èƒ½
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
        });

        hands.onResults(onResults);

        const camera = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({ image: videoElement });
            },
            width: 1280,
            height: 720
        });

        function onResults(results) {
            const videoWidth = videoElement.videoWidth;
            const videoHeight = videoElement.videoHeight;

            canvasElement.width = videoWidth;
            canvasElement.height = videoHeight;

            // ç»˜åˆ¶é›ªèŠ±
            updateAndDrawFlakes();

            if (!results.multiHandLandmarks) {
                isDrawing = false;
                isScaling = false;
                return;
            }

            let isHandOpen = false;
            let clearGestureDetected = false;
            let handsForScaling = [];
            let activeHandLandmarks = null;

            results.multiHandLandmarks.forEach((handLandmarks, index) => {
                const handLabel = results.multiHandedness[index].label;
                const wrist = handLandmarks[0];
                const indexTip = handLandmarks[8];
                const thumbTip = handLandmarks[4];
                const middleTip = handLandmarks[12];
                const pinkyTip = handLandmarks[20];

                // ä¼˜å…ˆä½¿ç”¨å³æ‰‹è¿›è¡Œç»˜åˆ¶å’ŒUIäº¤äº’
                if (handLabel === 'Right' && !activeHandLandmarks) {
                    activeHandLandmarks = handLandmarks;
                } else if (!activeHandLandmarks) {
                    activeHandLandmarks = handLandmarks; // å¦‚æœæ²¡æœ‰å³æ‰‹ï¼Œç”¨å·¦æ‰‹
                }

                // æ”¶é›†ç”¨äºç¼©æ”¾çš„é£ŸæŒ‡
                handsForScaling.push({ label: handLabel, tip: indexTip });

                // æ£€æµ‹â€œå¼ å¼€æ‰‹æŒâ€æ‰‹åŠ¿ (å°æŒ‡åˆ°æ‰‹è…•çš„è·ç¦»)
                const palmOpenDistance = Math.hypot(
                    pinkyTip.x - wrist.x,
                    pinkyTip.y - wrist.y
                );
                if (palmOpenDistance > 0.25) isHandOpen = true;

                // æ£€æµ‹â€œæ¸…é™¤â€æ‰‹åŠ¿ (é£ŸæŒ‡å’Œä¸­æŒ‡å¼ å¼€)
                const clearDistance = Math.hypot(
                    indexTip.x - middleTip.x,
                    indexTip.y - middleTip.y
                );
                if (clearDistance > 0.15) clearGestureDetected = true;
            });

            // --- å…¨å±€æ‰‹åŠ¿å¤„ç† ---

            // UIé¢æ¿é˜²æŠ–
            if (isHandOpen) {
                if (uiToggleTimeout) clearTimeout(uiToggleTimeout);
                uiToggleTimeout = setTimeout(() => {
                    showUI = !showUI;
                    uiPanel.style.display = showUI ? 'flex' : 'none';
                    isDrawing = false; // åˆ‡æ¢UIæ—¶åœæ­¢ç»˜åˆ¶
                    isScaling = false;
                }, 300);
            }

            // æ¸…é™¤ç”»å¸ƒ
            if (clearGestureDetected && !showUI) {
                createFlakesFromCanvas();
                canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            }

            // ç¼©æ”¾ç”»å¸ƒ
            if (handsForScaling.length === 2 && !showUI) {
                const distance = Math.hypot(
                    handsForScaling[0].tip.x - handsForScaling[1].tip.x,
                    handsForScaling[0].tip.y - handsForScaling[1].tip.y
                );
                if (!isScaling) {
                    initialScaleDistance = distance;
                    isScaling = true;
                } else {
                    const scaleFactor = distance / initialScaleDistance;
                    currentScale = Math.max(0.5, Math.min(3, scaleFactor * currentScale)); // é™åˆ¶ç¼©æ”¾èŒƒå›´
                    canvasElement.style.transform = `scale(${currentScale})`;
                    canvasElement.style.transformOrigin = 'center';
                }
            } else {
                isScaling = false;
            }

            // å¦‚æœæ²¡æœ‰æ´»è·ƒçš„æ‰‹ï¼Œæˆ–è€…UIæ­£åœ¨æ˜¾ç¤ºï¼Œåˆ™ä¸å¤„ç†ç»˜åˆ¶
            if (!activeHandLandmarks || showUI) {
                isDrawing = false;
                return;
            }

            // --- ç»˜åˆ¶/UIäº¤äº’é€»è¾‘ ---
            const indexTip = activeHandLandmarks[8];
            const thumbTip = activeHandLandmarks[4];

            // åæ ‡è½¬æ¢
            const x = indexTip.x * canvasElement.width;
            const y = indexTip.y * canvasElement.height;

            // ç»˜åˆ¶/æ“¦é™¤é€»è¾‘
            const pinchDistance = Math.hypot(
                indexTip.x - thumbTip.x,
                indexTip.y - thumbTip.y
            );

            if (pinchDistance < 0.05) { // æåˆæ‰‹åŠ¿
                if (!isDrawing) {
                    isDrawing = true;
                    [lastX, lastY] = [x, y];
                } else {
                    if (currentTool === 'pen') {
                        canvasCtx.beginPath();
                        canvasCtx.moveTo(lastX, lastY);
                        canvasCtx.lineTo(x, y);
                        canvasCtx.strokeStyle = currentColor;
                        canvasCtx.lineWidth = currentSize;
                        canvasCtx.lineCap = 'round';
                        canvasCtx.lineJoin = 'round';
                        canvasCtx.stroke();
                    } else { // Eraser
                        canvasCtx.clearRect(x - currentSize / 2, y - currentSize / 2, currentSize, currentSize);
                    }
                    [lastX, lastY] = [x, y];
                }
            } else {
                isDrawing = false;
            }
        }

        function updateAndDrawFlakes() {
            for (let i = flakes.length - 1; i >= 0; i--) {
                flakes[i].update();
                flakes[i].draw();
                if (flakes[i].opacity <= 0 || flakes[i].y > canvasElement.height) {
                    flakes.splice(i, 1);
                }
            }
        }

        function createFlakesFromCanvas() {
            const imageData = canvasCtx.getImageData(0, 0, canvasElement.width, canvasElement.height);
            const pixels = imageData.data;
            flakes = [];
            const sampleRate = 15; // é‡‡æ ·ç‡ï¼Œå€¼è¶Šå¤§ç²’å­è¶Šå°‘

            for (let y = 0; y < canvasElement.height; y += sampleRate) {
                for (let x = 0; x < canvasElement.width; x += sampleRate) {
                    const index = (y * canvasElement.width + x) * 4;
                    const alpha = pixels[index + 3];
                    if (alpha > 10) { // å¿½ç•¥å‡ ä¹é€æ˜çš„åƒç´ 
                        const r = pixels[index];
                        const g = pixels[index + 1];
                        const b = pixels[index + 2];
                        const color = `rgb(${r}, ${g}, ${b})`;
                        const size = Math.random() * 3 + 1;
                        flakes.push(new Flake(x, y, color, size));
                    }
                }
            }
        }

        camera.start();
    </script>
</body>
</html>