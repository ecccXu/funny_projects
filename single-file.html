<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç²¾å‡†æ‰‹åŠ¿ç”»æ¿ | æœ€ç»ˆç‰ˆ</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.min.js"></script>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; font-family: sans-serif; }
        body { display: flex; flex-direction: column; align-items: center; background: #121212; color: #e0e0e0; min-height: 100vh; padding: 20px; }
        h1 { color: #4CAF50; margin-bottom: 20px; }
        #container { position: relative; width: 90vw; max-width: 1024px; height: calc(90vw * 9 / 16); max-height: 576px; border: 2px solid #444; border-radius: 12px; overflow: hidden; box-shadow: 0 8px 32px rgba(0,0,0,0.5); }
        #video { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); filter: brightness(0.7); }
        #drawingCanvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; cursor: none; }
        #ui-panel { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(30,30,30,0.95); border: 1px solid #555; border-radius: 15px; padding: 20px; display: none; gap: 20px; align-items: center; z-index: 10; backdrop-filter: blur(10px); }
        .tool-group, .color-group, .size-group { display: flex; flex-direction: column; gap: 10px; align-items: center; }
        .tool-btn, .color-btn, .size-option { cursor: pointer; transition: all 0.2s ease; }
        .tool-btn { width: 60px; height: 60px; border-radius: 50%; border: 2px solid transparent; display: flex; align-items: center; justify-content: center; font-size: 24px; color: #fff; background: #333; }
        .tool-btn.active { border-color: #4CAF50; background: #444; box-shadow: 0 0 15px #4CAF50; }
        .color-btn { width: 40px; height: 40px; border-radius: 50%; border: 3px solid #555; }
        .color-btn.active { transform: scale(1.2); box-shadow: 0 0 10px currentColor; }
        .size-option { width: 50px; height: 8px; background: #666; border-radius: 4px; }
        .size-option.active { background: #4CAF50; box-shadow: 0 0 10px #4CAF50; }
        #size-1 { height: 5px; } #size-2 { height: 12px; } #size-3 { height: 20px; }
        .instructions { margin-top: 20px; text-align: center; font-size: 14px; color: #aaa; max-width: 800px; line-height: 1.6; }
        .instructions strong { color: #4CAF50; }
        #status-indicator { position: absolute; bottom: 20px; left: 20px; background: rgba(0,0,0,0.7); color: #4CAF50; padding: 8px 12px; border-radius: 20px; font-size: 14px; z-index: 20; }
    </style>
</head>
<body>
    <h1>ç²¾å‡†æ‰‹åŠ¿ç”»æ¿ (æœ€ç»ˆç‰ˆ)</h1>
    <div id="container">
        <video id="video" playsinline autoplay muted></video>
        <canvas id="drawingCanvas"></canvas>
        <div id="ui-panel">
            <div class="tool-group">
                <div id="pen-btn" class="tool-btn active" title="ç”»ç¬”">âœï¸</div>
                <div id="eraser-btn" class="tool-btn" title="æ©¡çš®æ“¦">ğŸ§½</div>
            </div>
            <div class="color-group">
                <div class="color-btn active" style="background-color: #FFFFFF;" data-color="#FFFFFF"></div>
                <div class="color-btn" style="background-color: #FF3B30;" data-color="#FF3B30"></div>
                <div class="color-btn" style="background-color: #FF9500;" data-color="#FF9500"></div>
                <div class="color-btn" style="background-color: #FFCC00;" data-color="#FFCC00"></div>
                <div class="color-btn" style="background-color: #4CD964;" data-color="#4CD964"></div>
                <div class="color-btn" style="background-color: #5AC8FA;" data-color="#5AC8FA"></div>
                <div class="color-btn" style="background-color: #007AFF;" data-color="#007AFF"></div>
                <div class="color-btn" style="background-color: #5856D6;" data-color="#5856D6"></div>
                <div class="color-btn" style="background-color: #FF2D55;" data-color="#FF2D55"></div>
            </div>
            <div class="size-group">
                <div id="size-1" class="size-option active" data-size="5"></div>
                <div id="size-2" class="size-option" data-size="15"></div>
                <div id="size-3" class="size-option" data-size="30"></div>
            </div>
        </div>
        <div id="status-indicator">ç©ºé—²: å¼ å¼€æ‰‹æŒä»¥æ˜¾ç¤ºèœå•</div>
    </div>
    <div class="instructions">
        <p><strong>ç²¾å‡†æ‰‹åŠ¿æŒ‡ä»¤:</strong></p>
        <p><strong>å¼ å¼€æ‰‹æŒ</strong> â†’ æ˜¾ç¤º/éšè—èœå• | èœå•ä¸­ï¼Œ<strong>é£ŸæŒ‡æ‚¬åœ+æåˆæ‹‡æŒ‡</strong> â†’ ç‚¹å‡»é€‰æ‹©</p>
        <p><strong>é£ŸæŒ‡æ‹‡æŒ‡æåˆ</strong> â†’ å¼€å§‹ç»˜åˆ¶/æ“¦é™¤ | <strong>æ¾å¼€æ‰‹æŒ‡</strong> â†’ åœæ­¢</p>
        <p><strong>å•æ‰‹é£ŸæŒ‡ä¸­æŒ‡å¼ å¼€</strong> â†’ æ¸…é™¤ç”»å¸ƒ | <strong>åŒæ‰‹é£ŸæŒ‡å¼ å¼€</strong> â†’ ç¼©æ”¾ç”»å¸ƒ</p>
    </div>

    <script>
        const videoElement = document.getElementById('video');
        const canvasElement = document.getElementById('drawingCanvas');
        const canvasCtx = canvasElement.getContext('2d');
        const uiPanel = document.getElementById('ui-panel');
        const statusIndicator = document.getElementById('status-indicator');

        // --- åº”ç”¨çŠ¶æ€ä¸é…ç½® ---
        const appState = {
            current: 'idle', // 'idle', 'ui_active', 'drawing', 'scaling'
            tool: 'pen',
            color: '#FFFFFF',
            size: 5,
            lastPos: { x: 0, y: 0 },
            initialScaleDistance: 0,
            currentScale: 1,
            uiToggleTimeout: null,
            activeHandIndex: 0,
        };

        // --- é›ªèŠ±ç²’å­ç³»ç»Ÿ ---
        let flakes = [];
        class Flake { /* ... (é›ªèŠ±ç±»ä»£ç ä¿æŒä¸å˜) ... */
            constructor(x, y, color, size) {
                this.x = x; this.y = y; this.size = size; this.color = color;
                this.velocityY = Math.random() * 1.5 + 0.5;
                this.velocityX = (Math.random() - 0.5) * 0.5;
                this.opacity = 1;
            }
            update() {
                this.y += this.velocityY;
                this.x += this.velocityX;
                this.velocityY += 0.05;
                this.opacity -= 0.005;
            }
            draw() {
                canvasCtx.save();
                canvasCtx.globalAlpha = this.opacity;
                canvasCtx.fillStyle = this.color;
                canvasCtx.beginPath();
                canvasCtx.arc(this.x, this.y, this.size / 2, 0, 2 * Math.PI);
                canvasCtx.fill();
                canvasCtx.restore();
            }
        }

        // --- DOM äº‹ä»¶ç»‘å®š ---
        const toolButtons = document.querySelectorAll('.tool-btn');
        const colorButtons = document.querySelectorAll('.color-btn');
        const sizeOptions = document.querySelectorAll('.size-option');
        toolButtons.forEach(btn => btn.addEventListener('click', (e) => {
            toolButtons.forEach(b => b.classList.remove('active'));
            e.target.classList.add('active');
            appState.tool = e.target.id === 'pen-btn' ? 'pen' : 'eraser';
        }));
        colorButtons.forEach(btn => btn.addEventListener('click', (e) => {
            colorButtons.forEach(b => b.classList.remove('active'));
            e.target.classList.add('active');
            appState.color = e.target.dataset.color;
        }));
        sizeOptions.forEach(option => option.addEventListener('click', (e) => {
            sizeOptions.forEach(o => o.classList.remove('active'));
            e.target.classList.add('active');
            appState.size = parseInt(e.target.dataset.size);
        }));

        // --- æ‰‹åŠ¿åˆ¤æ–­è¾…åŠ©å‡½æ•° ---
        const getDistance = (p1, p2) => Math.hypot(p1.x - p2.x, p1.y - p2.y);
        const isPinching = (hand) => getDistance(hand[8], hand[4]) < 0.08;
        const isPalmOpen = (hand) => getDistance(hand[20], hand[0]) > 0.25;
        const isClearing = (hand) => getDistance(hand[8], hand[12]) > 0.18;

        // --- çŠ¶æ€å¤„ç†å‡½æ•° ---
        const handleIdleState = (activeHand) => {
            if (isPalmOpen(activeHand)) {
                if (appState.uiToggleTimeout) clearTimeout(appState.uiToggleTimeout);
                appState.uiToggleTimeout = setTimeout(() => {
                    uiPanel.style.display = uiPanel.style.display === 'flex' ? 'none' : 'flex';
                    appState.current = uiPanel.style.display === 'flex' ? 'ui_active' : 'idle';
                    updateStatus();
                }, 300);
            } else if (isPinching(activeHand)) {
                appState.current = 'drawing';
                const indexTip = activeHand[8];
                appState.lastPos = {
                    x: indexTip.x * canvasElement.width,
                    y: indexTip.y * canvasElement.height
                };
                updateStatus();
            } else if (isClearing(activeHand)) {
                createFlakesFromCanvas();
                canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            }
        };

        const handleUIState = (activeHand) => {
            const indexTip = activeHand[8];
            const x = indexTip.x * canvasElement.width;
            const y = indexTip.y * canvasElement.height;

            // ç»˜åˆ¶UIå…‰æ ‡
            canvasCtx.save();
            canvasCtx.beginPath();
            canvasCtx.arc(x, y, 18, 0, 2 * Math.PI);
            canvasCtx.fillStyle = 'rgba(76, 175, 80, 0.3)';
            canvasCtx.fill();
            canvasCtx.beginPath();
            canvasCtx.arc(x, y, 6, 0, 2 * Math.PI);
            canvasCtx.fillStyle = '#4CAF50';
            canvasCtx.fill();
            canvasCtx.restore();

            if (isPalmOpen(activeHand)) {
                if (appState.uiToggleTimeout) clearTimeout(appState.uiToggleTimeout);
                appState.uiToggleTimeout = setTimeout(() => {
                    uiPanel.style.display = 'none';
                    appState.current = 'idle';
                    updateStatus();
                }, 300);
            } else if (isPinching(activeHand)) {
                const panelRect = uiPanel.getBoundingClientRect();
                const clickX = x * (panelRect.width / canvasElement.width) + panelRect.left;
                const clickY = y * (panelRect.height / canvasElement.height) + panelRect.top;
                const element = document.elementFromPoint(clickX, clickY);
                if (element && element.closest('#ui-panel')) {
                    element.click();
                }
            }
        };

        const handleDrawingState = (activeHand) => {
            if (!isPinching(activeHand)) {
                appState.current = 'idle';
                updateStatus();
                return;
            }

            const indexTip = activeHand[8];
            const currentPos = {
                x: indexTip.x * canvasElement.width,
                y: indexTip.y * canvasElement.height
            };

            if (appState.tool === 'pen') {
                canvasCtx.beginPath();
                canvasCtx.moveTo(appState.lastPos.x, appState.lastPos.y);
                canvasCtx.lineTo(currentPos.x, currentPos.y);
                canvasCtx.strokeStyle = appState.color;
                canvasCtx.lineWidth = appState.size;
                canvasCtx.lineCap = 'round';
                canvasCtx.stroke();
            } else { // Eraser
                canvasCtx.clearRect(currentPos.x - appState.size / 2, currentPos.y - appState.size / 2, appState.size, appState.size);
            }
            appState.lastPos = currentPos;
        };

        const handleScalingState = (hands) => {
            const leftHand = hands.find((_, i) => results.multiHandedness[i].label === 'Left');
            const rightHand = hands.find((_, i) => results.multiHandedness[i].label === 'Right');
            if (!leftHand || !rightHand) {
                appState.current = 'idle';
                updateStatus();
                return;
            }
            const currentDistance = getDistance(leftHand[8], rightHand[8]);
            if (appState.initialScaleDistance === 0) {
                appState.initialScaleDistance = currentDistance;
            }
            const scaleFactor = currentDistance / appState.initialScaleDistance;
            appState.currentScale = Math.max(0.5, Math.min(3, scaleFactor * appState.currentScale));
            canvasElement.style.transform = `scale(${appState.currentScale})`;
            canvasElement.style.transformOrigin = 'center';
        };

        // --- ä¸»æ›´æ–°å¾ªç¯ ---
        function onResults(results) {
            const videoWidth = videoElement.videoWidth;
            const videoHeight = videoElement.videoHeight;
            canvasElement.width = videoWidth;
            canvasElement.height = videoHeight;

            updateAndDrawFlakes();

            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                if (appState.current !== 'idle') {
                    appState.current = 'idle';
                    appState.initialScaleDistance = 0;
                    updateStatus();
                }
                return;
            }

            appState.activeHandIndex = results.multiHandedness.findIndex(h => h.label === 'Right');
            if (appState.activeHandIndex === -1) appState.activeHandIndex = 0;
            const activeHand = results.multiHandLandmarks[appState.activeHandIndex];

            switch (appState.current) {
                case 'idle':
                    if (results.multiHandLandmarks.length === 2) {
                         appState.current = 'scaling';
                         updateStatus();
                    } else {
                        handleIdleState(activeHand);
                    }
                    break;
                case 'ui_active':
                    handleUIState(activeHand);
                    break;
                case 'drawing':
                    handleDrawingState(activeHand);
                    break;
                case 'scaling':
                    if (results.multiHandLandmarks.length < 2) {
                        appState.current = 'idle';
                        appState.initialScaleDistance = 0;
                        updateStatus();
                    } else {
                        handleScalingState(results.multiHandLandmarks);
                    }
                    break;
            }
        }

        // --- è¾…åŠ©å‡½æ•° ---
        function updateStatus() {
            const messages = {
                'idle': 'ç©ºé—²: å¼ å¼€æ‰‹æŒä»¥æ˜¾ç¤ºèœå•',
                'ui_active': 'é€‰æ‹©å·¥å…·: é£ŸæŒ‡æ‚¬åœï¼Œæåˆæ‹‡æŒ‡ç‚¹å‡»',
                'drawing': `ç»˜åˆ¶ä¸­ (${appState.tool}): æ¾å¼€æ‰‹æŒ‡åœæ­¢`,
                'scaling': 'ç¼©æ”¾ä¸­: ç§»åŠ¨åŒæ‰‹æŒ‡å°–',
            };
            statusIndicator.textContent = messages[appState.current];
        }

        function updateAndDrawFlakes() {
            for (let i = flakes.length - 1; i >= 0; i--) {
                flakes[i].update();
                flakes[i].draw();
                if (flakes[i].opacity <= 0 || flakes[i].y > canvasElement.height) flakes.splice(i, 1);
            }
        }

        function createFlakesFromCanvas() {
            const imageData = canvasCtx.getImageData(0, 0, canvasElement.width, canvasElement.height);
            const pixels = imageData.data;
            flakes = [];
            for (let y = 0; y < canvasElement.height; y += 15) {
                for (let x = 0; x < canvasElement.width; x += 15) {
                    const i = (y * canvasElement.width + x) * 4;
                    if (pixels[i + 3] > 10) {
                        flakes.push(new Flake(x, y, `rgb(${pixels[i]},${pixels[i+1]},${pixels[i+2]})`, Math.random() * 3 + 1));
                    }
                }
            }
        }

        // --- åˆå§‹åŒ– MediaPipe å’Œ Camera ---
        const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
        hands.setOptions({ maxNumHands: 2, modelComplexity: 0, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
        hands.onResults(onResults);

        const camera = new Camera(videoElement, {
            onFrame: async () => await hands.send({ image: videoElement }),
            width: 1280, height: 720
        });

        camera.start();
    </script>
</body>
</html>