<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MediaPipe 隔空写字与交互系统（优化版）</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f2f5;
            margin: 0;
            padding: 20px;
            color: #333;
        }
        h1 {
            color: #1a73e8;
            margin-bottom: 20px;
        }
        #container {
            position: relative;
            width: 80vw;
            max-width: 1280px;
            height: calc(80vw * 9 / 16);
            max-height: 720px;
            border: 2px solid #ccc;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            background-color: #fff;
            overflow: hidden;
        }
        #video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* 水平镜像，符合直觉 */
        }
        #drawingCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }
        #ui-panel {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 15px;
            display: none; /* 默认隐藏 */
            gap: 15px;
            align-items: center;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
            z-index: 10;
        }
        .tool-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 2px solid #ddd;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            background-color: #fff;
        }
        .tool-btn:hover, .tool-btn.active {
            border-color: #1a73e8;
            background-color: #e8f0fe;
        }
        #pen-btn { background-color: #4CAF50; }
        #eraser-btn { background-color: #f44336; }
        .color-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid #fff;
            cursor: pointer;
            box-shadow: inset 0 0 0 2px #ddd;
            transition: transform 0.2s ease;
        }
        .color-btn:hover {
            transform: scale(1.1);
        }
        .size-option {
            width: 30px;
            height: 8px;
            background-color: #aaa;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .size-option:hover, .size-option.active {
            background-color: #1a73e8;
        }
        #size-1 { width: 20px; }
        #size-2 { width: 35px; }
        #size-3 { width: 50px; }

        .instruction {
            margin-top: 15px;
            font-size: 14px;
            color: #555;
            text-align: center;
            line-height: 1.6;
        }
        .instruction strong {
            color: #1a73e8;
        }
    </style>
</head>
<body>
    <h1>MediaPipe 隔空写字与交互系统（优化版）</h1>
    <div id="container">
        <video id="video" playsinline autoplay muted></video>
        <canvas id="drawingCanvas"></canvas>

        <!-- UI 控制面板 -->
        <div id="ui-panel">
            <button id="pen-btn" class="tool-btn active" title="笔 (Pen)"></button>
            <button id="eraser-btn" class="tool-btn" title="橡皮擦 (Eraser)"></button>
            <div class="colors">
                <button class="color-btn active" style="background-color: #000000;" data-color="#000000"></button>
                <button class="color-btn" style="background-color: #FF0000;" data-color="#FF0000"></button>
                <button class="color-btn" style="background-color: #00FF00;" data-color="#00FF00"></button>
                <button class="color-btn" style="background-color: #0000FF;" data-color="#0000FF"></button>
                <button class="color-btn" style="background-color: #FFFF00;" data-color="#FFFF00"></button>
            </div>
            <div class="sizes">
                <div id="size-1" class="size-option active" data-size="5"></div>
                <div id="size-2" class="size-option" data-size="15"></div>
                <div id="size-3" class="size-option" data-size="25"></div>
            </div>
        </div>
    </div>

    <div class="instruction">
        <p><strong>手势指令:</strong></p>
        <p>张开手掌 → 显示/隐藏控制面板 | 食指点击 → 选择功能 | 食指拇指相触 → 开始书写/擦除</p>
        <p>双手食指张开 → 缩放画布 | 单手食指中指张开 → 清除画布 (雪花消散)</p>
    </div>

    <script>
        const videoElement = document.getElementById('video');
        const canvasElement = document.getElementById('drawingCanvas');
        const canvasCtx = canvasElement.getContext('2d');
        const uiPanel = document.getElementById('ui-panel');

        // --- 应用状态 ---
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let currentTool = 'pen'; // 'pen' or 'eraser'
        let currentColor = '#000000';
        let currentSize = 5;
        let showUI = false;
        let uiToggleTimeout = null; // UI防抖定时器

        // --- 雪花粒子系统 (用于消散效果) ---
        let flakes = [];
        const GRAVITY = 0.1;
        const WIND_SPEED = 0.5;

        class Flake {
            constructor(x, y, color, size) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.color = color;
                this.velocityY = (Math.random() * 2) + 1; // 下落速度
                this.velocityX = (Math.random() - 0.5) * WIND_SPEED; // 水平飘动
                this.opacity = 1;
                this.rotation = Math.random() * 360;
                this.rotationSpeed = (Math.random() - 0.5) * 2;
            }
            update() {
                this.y += this.velocityY;
                this.x += this.velocityX;
                this.velocityY += GRAVITY;
                this.opacity -= 0.004;
                this.rotation += this.rotationSpeed;
            }
            draw() {
                canvasCtx.save();
                canvasCtx.globalAlpha = this.opacity;
                canvasCtx.translate(this.x, this.y);
                canvasCtx.rotate(this.rotation * Math.PI / 180);
                canvasCtx.fillStyle = this.color;
                canvasCtx.beginPath();
                canvasCtx.arc(0, 0, this.size / 2, 0, 2 * Math.PI);
                canvasCtx.fill();
                canvasCtx.restore();
            }
        }

        // --- 工具选择逻辑 ---
        document.querySelectorAll('.tool-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                currentTool = e.target.id === 'pen-btn' ? 'pen' : 'eraser';
            });
        });

        document.querySelectorAll('.color-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                currentColor = e.target.dataset.color;
            });
        });

        document.querySelectorAll('.size-option').forEach(option => {
            option.addEventListener('click', (e) => {
                document.querySelectorAll('.size-option').forEach(o => o.classList.remove('active'));
                e.target.classList.add('active');
                currentSize = parseInt(e.target.dataset.size);
            });
        });

        // --- 手势检测与交互逻辑 ---
        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        // 优化：降低模型复杂度，减少算力消耗
        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 0, // 轻量模型（原1）
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        // 优化：降低摄像头分辨率，减少采集数据量
        const camera = new Camera(videoElement, {
            onFrame: async () => { /* 改为手动控制帧率，此处留空 */ },
            width: 640,  // 原1280
            height: 360  // 原720
        });

        // 优化：手动控制检测帧率（20帧/秒），降低算力占用
        setInterval(async () => {
            if (videoElement.readyState === videoElement.HAVE_ENOUGH_DATA) {
                await hands.send({ image: videoElement });
            }
        }, 50);

        function onResults(results) {
            const container = document.getElementById('container');
            const videoWidth = videoElement.videoWidth;
            const videoHeight = videoElement.videoHeight;

            // 设置画布尺寸以匹配视频流
            canvasElement.width = videoWidth;
            canvasElement.height = videoHeight;

            // 绘制雪花粒子
            updateAndDrawFlakes();

            // 如果没有检测到手，重置状态
            if (!results.multiHandLandmarks) {
                isDrawing = false;
                showUI = false;
                uiPanel.style.display = 'none';
                return;
            }

            let isHandOpen = false;
            let clearGestureDetected = false;
            let handsForScaling = [];

            // 遍历所有检测到的手
            results.multiHandLandmarks.forEach((handLandmarks, index) => {
                const handLabel = results.multiHandedness[index].label; // "Left" or "Right"

                const indexTip = handLandmarks[8];
                const thumbTip = handLandmarks[4];
                const middleTip = handLandmarks[12];

                // 计算食指和拇指指尖的距离
                const pinchDistance = Math.hypot(
                    indexTip.x - thumbTip.x,
                    indexTip.y - thumbTip.y
                );

                // 计算食指和中指指尖的距离（用于清除手势）
                const clearDistance = Math.hypot(
                    indexTip.x - middleTip.x,
                    indexTip.y - middleTip.y
                );

                // 优化：调整手掌张开阈值，减少误判
                const pinkyTip = handLandmarks[20];
                const wrist = handLandmarks[0];
                const palmOpenDistance = Math.hypot(
                    pinkyTip.x - wrist.x,
                    pinkyTip.y - wrist.y
                );
                if (palmOpenDistance > 0.25) { // 阈值从0.2调整为0.25
                    isHandOpen = true;
                }

                // 检测“清除”手势 (食指和中指张开)
                if (clearDistance > 0.15) {
                    clearGestureDetected = true;
                }

                // 收集用于缩放的食指位置
                handsForScaling.push({ label: handLabel, tip: indexTip });

                // 坐标转换：从视频坐标转换到画布坐标
                const x = indexTip.x * canvasElement.width;
                const y = indexTip.y * canvasElement.height;

                // 处理UI选择
                if (showUI) {
                    const panelRect = uiPanel.getBoundingClientRect();
                    const containerRect = container.getBoundingClientRect();

                    const scaledX = x * (containerRect.width / videoWidth);
                    const scaledY = y * (containerRect.height / videoHeight);

                    const clickX = scaledX + containerRect.left - panelRect.left;
                    const clickY = scaledY + containerRect.top - panelRect.top;

                    const elements = document.elementsFromPoint(clickX + panelRect.left, clickY + panelRect.top);
                    for (const el of elements) {
                        if (el.closest('#ui-panel') && el.tagName === 'BUTTON' || el.tagName === 'DIV') {
                            el.click();
                            break;
                        }
                    }
                }

                // 处理书写/擦除
                if (pinchDistance < 0.05) {
                    if (!isDrawing) {
                        isDrawing = true;
                        [lastX, lastY] = [x, y];
                    } else {
                        if (currentTool === 'pen') {
                            canvasCtx.beginPath();
                            canvasCtx.moveTo(lastX, lastY);
                            canvasCtx.lineTo(x, y);
                            canvasCtx.strokeStyle = currentColor;
                            canvasCtx.lineWidth = currentSize;
                            canvasCtx.lineCap = 'round';
                            canvasCtx.stroke();
                        } else if (currentTool === 'eraser') {
                            canvasCtx.clearRect(x - currentSize / 2, y - currentSize / 2, currentSize, currentSize);
                        }
                        [lastX, lastY] = [x, y];
                    }
                } else {
                    isDrawing = false;
                }
            });

            // --- 全局状态更新 ---

            // 优化：UI面板防抖，避免频繁闪烁
            if (isHandOpen) {
                if (uiToggleTimeout) clearTimeout(uiToggleTimeout);
                uiToggleTimeout = setTimeout(() => {
                    showUI = !showUI;
                    uiPanel.style.display = showUI ? 'flex' : 'none';
                }, 300); // 300毫秒防抖延迟
            }

            // 处理清除画布
            if (clearGestureDetected) {
                createFlakesFromCanvas();
                canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            }

            // 处理缩放
            if (handsForScaling.length === 2) {
                const leftHand = handsForScaling.find(h => h.label === 'Left');
                const rightHand = handsForScaling.find(h => h.label === 'Right');
                if (leftHand && rightHand) {
                    const distance = Math.hypot(
                        leftHand.tip.x - rightHand.tip.x,
                        leftHand.tip.y - rightHand.tip.y
                    );
                    const scale = distance * 2;
                    canvasElement.style.transform = `scale(${scale})`;
                    canvasElement.style.transformOrigin = 'center';
                }
            } else {
                canvasElement.style.transform = 'scale(1)';
            }
        }

        function updateAndDrawFlakes() {
            for (let i = flakes.length - 1; i >= 0; i--) {
                flakes[i].update();
                flakes[i].draw();
                if (flakes[i].opacity <= 0 || flakes[i].y > canvasElement.height) {
                    flakes.splice(i, 1);
                }
            }
        }

        // 优化：增大粒子采样步长，减少粒子数量
        function createFlakesFromCanvas() {
            const imageData = canvasCtx.getImageData(0, 0, canvasElement.width, canvasElement.height);
            const pixels = imageData.data;

            flakes = [];

            // 步长从10改为20，减少粒子生成量
            for (let y = 0; y < canvasElement.height; y += 20) {
                for (let x = 0; x < canvasElement.width; x += 20) {
                    const index = (y * canvasElement.width + x) * 4;
                    const alpha = pixels[index + 3];
                    if (alpha > 0) {
                        const r = pixels[index];
                        const g = pixels[index + 1];
                        const b = pixels[index + 2];
                        const color = `rgb(${r}, ${g}, ${b})`;
                        const size = Math.random() * 5 + 1;
                        flakes.push(new Flake(x, y, color, size));
                    }
                }
            }
        }

        // 启动摄像头
        camera.start();
    </script>
</body>
</html>